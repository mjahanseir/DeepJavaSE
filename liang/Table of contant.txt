Table of Contents:
- Chapter 1 Introduction to Computers, Programs, and Java™
- Chapter 2 Elementary Programming
- Chapter 3 Selections
- Chapter 4 Mathematical Functions, Characters, and Strings
- Chapter 5 Loops
- Chapter 6 Methods
- Chapter 7 Single-Dimensional Arrays
- Chapter 8 Multidimensional Arrays
- Chapter 9 Objects and Classes
- Chapter 10 Object-Oriented Thinking
- Chapter 11 Inheritance and Polymorphism
- Chapter 12 Exception Handling and Text I/O
- Chapter 13 Abstract Classes and Interfaces
- Chapter 14 JavaFX Basics
- Chapter 15 Event-Driven Programming and Animations
- Chapter 16 JavaFX UI Controls and Multimedia
- Chapter 17 Binary I/O
- Chapter 18 Recursion
- Chapter 19 Generics
- Chapter 20 Lists, Stacks, Queues, and Priority Queues
- Chapter 21 Sets and Maps
- Chapter 22 Developing Efficient Algorithms
- Chapter 23 Sorting
- Chapter 24 Implementing Lists, Stacks, Queues, and Priority Queues
- Chapter 25 Binary Search Trees
- Chapter 26 AVL Trees
- Chapter 27 Hashing
- Chapter 28 Graphs and Applications
- Chapter 29 Weighted Graphs and Applications
- Chapter - Chapter 30 Aggregate Operations for Collection Streams
- Chapter 31 Advanced JavaFX and FXML 
- Chapter 32 Multithreading and Parallel Programming 
- Chapter 3- Chapter 3 Networking 
- Chapter 34 Java Database Programming 
- Chapter 35 Advanced Java Database Programming 
- Chapter 36 Internationalization 
- Chapter 37 Servlets 
- Chapter 38 JavaServer Pages 
- Chapter 39 JavaServer Faces 
- Chapter 40 RMI 
- Chapter 41 Web Services 
- Chapter 42 2-4 Trees and B-Trees 
- Chapter 43 Red-Black Trees 
- Chapter 44 Testing Using JUnit 







************************   Part 1 - Ch 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8   ************************

Part I: Fundamentals of Programming (Chapters 1–8)
		The first part of the book is a stepping stone, preparing you to embark on the journey of learning Java. You will begin to learn about Java (Chapter 1) and fundamental programming techniques with primitive data types, variables, constants, assignments, expressions, and operators (Chapter 2), selection statements (Chapter 3), mathematical functions, characters, and strings (Chapter 4), loops (Chapter 5), methods (Chapter 6), and arrays (Chapters 7–8). After Chapter 7, you can jump to Chapter 18 to learn how to write recursive methods for solving inherently recursive problems.
	
	Chapter 1 Introduction to Computers, Programs, and Java™ 1
				1.1 Introduction 2
				1.2 What Is a Computer? 2
				1.3 Programming Languages 7
				1.4 Operating Systems 9
				1.5 Java, the World Wide Web, and Beyond 10
				1.6 The Java Language Specification, API, JDK, JRE, and IDE 11
				1.7 A Simple Java Program 12
				1.8 Creating, Compiling, and Executing a Java Program 15
				1.9 Programming Style and Documentation 18
				1.10 Programming Errors 19
				1.11 Developing Java Programs Using NetBeans 23
				1.12 Developing Java Programs Using Eclipse 26
	Chapter 2 Elementary Programming 33
				2.1 Introduction 34
				2.2 Writing a Simple Program 34
				2.3 Reading Input from the Console 37
				2.4 Identifiers 40
				2.5 Variables 40
				2.6 Assignment Statements and Assignment Expressions 42
				2.7 Named Constants 43
				2.8 Naming Conventions 44
				2.9 Numeric Data Types and Operations 45
				2.10 Numeric Literals 48
				2.11 JShell 50
				2.12 Evaluating Expressions and Operator Precedence 52
				2.13 Case Study: Displaying the Current Time 54
				2.14 Augmented Assignment Operators 56
				2.15 Increment and Decrement Operators 57
				2.16 Numeric Type Conversions 58
				2.17 Software Development Process 61
				2.18 Case Study: Counting Monetary Units 64
				2.19 Common Errors and Pitfalls 67
	Chapter 3 Selections 77
				3.1 Introduction 78
				3.2 boolean Data Type, Values, and Expressions 78
				3.3 if Statements 80
				3.4 Two-Way if-else Statements 82
				3.5 Nested if and Multi-Way if-else Statements 83
				3.6 Common Errors and Pitfalls 85
				3.7 Generating Random Numbers 89
				3.8 Case Study: Computing Body Mass Index 91
				3.9 Case Study: Computing Taxes 92
				3.10 Logical Operators 95
				3.11 Case Study: Determining Leap Year 99
				3.12 Case Study: Lottery 100
				3.13 switch Statements 102
				3.14 Conditional Operators 105
				3.15 Operator Precedence and Associativity 106
				3.16 Debugging 10
	Chapter 4 Mathematical Functions, Characters, and Strings 121
				4.1 Introduction 122
				4.2 Common Mathematical Functions 122
				4.3 Character Data Type and Operations 126
				4.4 The String Type 131
				4.5 Case Studies 140
				4.6 Formatting Console Output 146
	Chapter 5 Loops 159
				5.1 Introduction 160
				5.2 The while Loop 160
				5.3 Case Study: Guessing Numbers 163
				5.4 Loop Design Strategies 166
				5.5 Controlling a Loop with User Confirmation or a Sentinel Value 168
				5.6 The do-while Loop 171
				5.7 The for Loop 173
				5.8 Which Loop to Use? 176
				5.9 Nested Loops 178
				5.10 Minimizing Numeric Errors 180
				5.11 Case Studies 182
				5.12 Keywords break and continue 186
				5.13 Case Study: Checking Palindromes 189
				5.14 Case Study: Displaying Prime Numbers 191
	Chapter 6 Methods 205
				6.1 Introduction 206
				6.2 Defining a Method 206
				6.3 Calling a Method 208
				6.4 void vs. Value-Returning Methods 211
				6.5 Passing Arguments by Values 213
				6.6 Modularizing Code 217
				6.7 Case Study: Converting Hexadecimals to Decimals 219
				6.8 Overloading Methods 221
				6.9 The Scope of Variables 224
				6.10 Case Study: Generating Random Characters 225
				6.11 Method Abstraction and Stepwise Refinement 227
	Chapter 7 Single-Dimensional Arrays 249
				7.1 Introduction 250
				7.2 Array Basics 250
				7.3 Case Study: Analyzing Numbers 257
				7.4 Case Study: Deck of Cards 258
				7.5 Copying Arrays 260
				7.6 Passing Arrays to Methods 261
				7.7 Returning an Array from a Method 264
				7.8 Case Study: Counting the Occurrences of Each Letter 265
				7.9 Variable-Length Argument Lists 268
				7.10 Searching Arrays 269
				7.11 Sorting Arrays 273
				7.12 The Arrays Class 274
				7.13 Command-Line Arguments 276
	Chapter 8 Multidimensional Arrays 289
				8.1 Introduction 290
				8.2 Two-Dimensional Array Basics 290
				8.3 Processing Two-Dimensional Arrays 293
				8.4 Passing Two-Dimensional Arrays to Methods 295
				8.5 Case Study: Grading a Multiple-Choice Test 296
				8.6 Case Study: Finding the Closest Pair 298
				8.7 Case Study: Sudoku 300
				8.8 Multidimensional Arrays 303


************************   Part 2 - Ch 9 , 10 , 11 , 12 , 13 , 17   ************************

Part II: Object-Oriented Programming (Chapters 9–13, and 17)
		This part introduces object-oriented programming. Java is an object-oriented programming language that uses abstraction, encapsulation, inheritance, and polymorphism to provide great flexibility, modularity, and reusability in developing software. You will learn programming with objects and classes (Chapters 9–10), class inheritance (Chapter 11), polymorphism (Chapter 11), exception handling (Chapter 12), abstract classes (Chapter 13), and interfaces (Chapter 13). Text I/O is introduced in Chapter 12 and binary I/O is discussed in Chapter 17.

	Chapter 9 Objects and Classes 323
				9.1 Introduction 324
				9.2 Defining Classes for Objects 324
				9.3 Example: Defining Classes and Creating Objects 326
				9.4 Constructing Objects Using Constructors 331
				9.5 Accessing Objects via Reference Variables 332
				9.6 Using Classes from the Java Library 336
				9.7 Static Variables, Constants, and Methods 339
				9.8 Visibility Modifiers 344
				9.9 Data Field Encapsulation 346
				9.10 Passing Objects to Methods 349
				9.11 Array of Objects 353
				9.12 Immutable Objects and Classes 355
				9.13 The Scope of Variables 357
				9.14 The this Reference 358
	Chapter 10 Object-Oriented Thinking 367
				10.1 Introduction 368
				10.2 Class Abstraction and Encapsulation 368
				10.3 Thinking in Objects 372
				10.4 Class Relationships 375
				10.5 Case Study: Designing the Course Class 378
				10.6 Case Study: Designing a Class for Stacks 380
				10.7 Processing Primitive Data Type Values as Objects 382
				10.8 Automatic Conversion between Primitive Types and Wrapper Class Types 386
				10.9 The BigInteger and BigDecimal Classes 387
				10.10 The String Class 388
				10.11 The StringBuilder and StringBuffer Classes 395
	Chapter 11 Inheritance and Polymorphism 411
				11.1 Introduction 412
				11.2 Superclasses and Subclasses 412
				11.3 Using the super Keyword 418
				11.4 Overriding Methods 421
				11.5 Overriding vs. Overloading 422
				11.6 The Object Class and Its toString() Method 424
				11.7 Polymorphism 425
				11.8 Dynamic Binding 425
				11.9 Casting Objects and the instanceof Operator 429
				11.10 The Object’s equals Method 433
				11.11 The ArrayList Class 434
				11.12 Useful Methods for Lists 440
				11.13 Case Study: A Custom Stack Class 441
				11.14 The protected Data and Methods 442
				11.15 Preventing Extending and Overriding 445
	Chapter 12 Exception Handling and Text I/O 453
				12.1 Introduction 454
				12.2 Exception-Handling Overview 454
				12.3 Exception Types 459
				12.4 Declaring, Throwing, and Catching Exceptions 462
				12.5 The finally Clause 470
				12.6 When to Use Exceptions 472
				12.7 Rethrowing Exceptions 472
				12.8 Chained Exceptions 473
				12.9 Defining Custom Exception Classes 474
				12.10 The File Class 477
				12.11 File Input and Output 480
				12.12 Reading Data from the Web 487
				12.13 Case Study: Web Crawler 488
	Chapter 13 Abstract Classes and Interfaces 499
				13.1 Introduction 500
				13.2 Abstract Classes 500
				13.3 Case Study: The Abstract Number Class 505
				13.4 Case Study: Calendar and GregorianCalendar 507
				13.5 Interfaces 510
				13.6 The Comparable Interface 514
				13.7 The Cloneable Interface 518
				13.8 Interfaces vs. Abstract Classes 523
				13.9 Case Study: The Rational Class 526
				13.10 Class-Design Guidelines 531

	Chapter 17 Binary I/O 691
				17.1 Introduction 692
				17.2 How Is Text I/O Handled in Java? 692
				17.3 Text I/O vs. Binary I/O 693
				17.4 Binary I/O Classes 694
				17.5 Case Study: Copying Files 704
				17.6 Object I/O 706
				17.7 Random-Access Files 711


************************   Part 3 - Ch 14 , 15 , 16 , 31   ************************

Part III: GUI Programming (Chapters 14–16 and Bonus Chapter 31)
		JavaFX is a new framework for developing Java GUI programs. It is not only useful for developing GUI programs, but also an excellent pedagogical tool for learning object-oriented programming. This part introduces Java GUI programming using JavaFX in Chapters 14–16.
		Major topics include GUI basics (Chapter 14), container panes (Chapter 14), drawing shapes (Chapter 14), event-driven programming (Chapter 15), animations (Chapter 15), and GUI controls (Chapter 16), and playing audio and video (Chapter 16). You will learn the architecture of JavaFX GUI programming and use the controls, shapes, panes, image, and video to develop
		useful applications. Chapter 31 covers advanced features in JavaFX.

	Chapter 14 JavaFX Basics 541
				14.1 Introduction 542
				14.2 JavaFX vs Swing and AWT 542
				14.3 The Basic Structure of a JavaFX Program 542
				14.4 Panes, Groups, UI Controls, and Shapes 545
				14.5 Property Binding 548
				14.6 Common Properties and Methods for Nodes 551
				14.7 The Color Class 553
				14.8 The Font Class 554
				14.9 The Image and ImageView Classes 556
				14.10 Layout Panes and Groups 558
				14.11 Shapes 567
				14.12 Case Study: The ClockPane Class 580
	Chapter 15 Event-Driven Programming and Animations 593
				15.1 Introduction 594
				15.2 Events and Event Sources 596
				15.3 Registering Handlers and Handling Events 597
				15.4 Inner Classes 601
				15.5 Anonymous Inner Class Handlers 602
				15.6 Simplifying Event Handling Using Lambda Expressions 605
				15.7 Case Study: Loan Calculator 609
				15.8 Mouse Events 611
				15.9 Key Events 613
				15.10 Listeners for Observable Objects 616
				15.11 Animation 618
				15.12 Case Study: Bouncing Ball 626
				15.13 Case Study: US Map 630
	Chapter 16 JavaFX UI Controls and Multimedia 643
				16.1 Introduction 644
				16.2 Labeled and Label 644
				16.3 Button 646
				16.4 CheckBox 648
				16.5 RadioButton 651
				16.6 TextField 654
				16.7 TextArea 655
				16.8 ComboBox 659
				16.9 ListView 662
				16.10 ScrollBar 665
				16.11 Slider 668
				16.12 Case Study: Developing a Tic-Tac-Toe Game 671
				16.13 Video and Audio 676
				16.14 Case Study: National Flags and Anthems 679

				

************************   Part 4 - Ch 18, 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 42 , 43   ************************

Part IV: Data Structures and Algorithms (Chapters 18–30 and Bonus Chapters 42–43)
		This part covers the main subjects in a typical data structures and algorithms course. Chapter 18 introduces recursion to write methods for solving inherently recursive problems. Chapter 19 presents how generics can improve software reliability. Chapters 20 and 21 introduce the Java Collection Framework, which defines a set of useful API for data structures. Chapter 22 discusses measuring algorithm efficiency in order to choose an appropriate algorithm for applications. Chapter 23 describes classic sorting algorithms. You will learn how to implement several classic data structures lists, queues, and priority queues in Chapter 24. Chapters 25 and 26 introduce binary search trees and AVL trees. Chapter 27 presents hashing and implementing maps and sets using hashing.
		Chapters 28 and 29 introduce graph applications. Chapter 30 introduces aggregate operations for collection streams. The 2-4 trees, B-trees, and red-black trees are covered in Bonus Chapters 42–43.



	Chapter 18 Recursion 719
				* 18.1 Introduction 720
				* 18.2 Case Study: Computing Factorials 720
				* 18.3 Case Study: Computing Fibonacci Numbers 723
				18.4 Problem Solving Using Recursion 726
				18.5 Recursive Helper Methods 728
				18.6 Case Study: Finding the Directory Size 731
				18.7 Case Study: Tower of Hanoi 733
				18.8 Case Study: Fractals 736
				18.9 Recursion vs. Iteration 740
				18.10 Tail Recursion 740
	Chapter 19 Generics 751
				19.1 Introduction 752
				19.2 Motivations and Benefits 752
				19.3 Defining Generic Classes and Interfaces 754
				19.4 Generic Methods 756
				19.5 Case Study: Sorting an Array of Objects 758
				19.6 Raw Types and Backward Compatibility 760
				19.7 Wildcard Generic Types 761
				19.8 Erasure and Restrictions on Generics 764
				19.9 Case Study: Generic Matrix Class 766
	Chapter 20 Lists, Stacks, Queues, and Priority Queues 775
				20.1 Introduction 776
				20.2 Collections 776
				20.3 Iterators 780
				20.4 Using the forEach Method 782
				20.5 Lists 783
				20.6 The Comparator Interface 787
				20.7 Static Methods for Lists and Collections 792
				20.8 Case Study: Bouncing Balls 795
				20.9 Vector and Stack Classes 798
				20.10 Queues and Priority Queues 800
				20.11 Case Study: Evaluating Expressions 803
	Chapter 21 Sets and Maps 815
				21.1 Introduction 816
				21.2 Sets 816
				21.3 Comparing the Performance of Sets and Lists 824
				21.4 Case Study: Counting Keywords 827
				21.5 Maps 828
				21.6 Case Study: Occurrences of Words 833
				21.7 Singleton and Unmodifiable Collections and Maps 835
	Chapter 22 Developing Efficient Algorithms 839
				22.1 Introduction 840
				22.2 Measuring Algorithm Efficiency Using Big ONotation 840
				22.3 Examples: Determining Big O 842
				22.4 Analyzing Algorithm Time Complexity 846
				22.5 Finding Fibonacci Numbers Using Dynamic Programming 849
				22.6 Finding Greatest Common Divisors Using Euclid’s Algorithm 851
				22.7 Efficient Algorithms for Finding Prime Numbers 855
				22.8 Finding the Closest Pair of Points Using Divide-and-Conquer 861
				22.9 Solving the Eight Queens Problem Using Backtracking 864
				22.10 Computational Geometry: Finding a Convex Hull 867
				22.11 String Matching 869
	Chapter 23 Sorting 887
				23.1 Introduction 888
				23.2 Insertion Sort 888
				23.3 Bubble Sort 890
				23.4 Merge Sort 892
				23.5 Quick Sort 896
				23.6 Heap Sort 900
				23.7 Bucket and Radix Sorts 907
				23.8 External Sort 909
	Chapter 24 Implementing Lists, Stacks, Queues, and Priority Queues 923
				24.1 Introduction 924
				24.2 Common Operations for Lists 924
				24.3 Array Lists 928
				24.4 Linked Lists 935
				24.5 Stacks and Queues 949
				24.6 Priority Queues 953
	Chapter 25 Binary Search Trees 959
				25.1 Introduction 960
				25.2 Binary Search Trees Basics 960
				25.3 Representing Binary Search Trees 961
				25.4 Searching for an Element 962
				25.5 Inserting an Element into a BST 962
				25.6 Tree Traversal 963
				25.7 The BST Class 965
				25.8 Deleting Elements from a BST 974
				25.9 Tree Visualization and MVC 980
				25.10 Iterators 983
				25.11 Case Study: Data Compression 985
	Chapter 26 AVL Trees 995
				26.1 Introduction 996
				26.2 Rebalancing Trees 996
				26.3 Designing Classes for AVL Trees 999
				26.4 Overriding the insert Method 1000
				26.5 Implementing Rotations 1001
				26.6 Implementing the delete Method 1002
				26.7 The AVLTree Class 1002
				26.8 Testing the AVLTree Class 1008
				26.9 AVL Tree Time Complexity Analysis 1011
	Chapter 27 Hashing 1015
				27.1 Introduction 1016
				27.2 What Is Hashing? 1016
				27.3 Hash Functions and Hash Codes 1017
				27.4 Handling Collisions Using Open Addressing 1019
				27.5 Handling Collisions Using Separate Chaining 1023
				27.6 Load Factor and Rehashing 1025
				27.7 Implementing a Map Using Hashing 1025
				27.8 Implementing Set Using Hashing 1034
	Chapter 28 Graphs and Applications 1045
				28.1 Introduction 1046
				28.2 Basic Graph Terminologies 1047
				28.3 Representing Graphs 1048
				28.4 Modeling Graphs 1054
				28.5 Graph Visualization 1064
				28.6 Graph Traversals 1067
				28.7 Depth-First Search (DFS) 1068
				28.8 Case Study: The Connected Circles Problem 1072
				28.9 Breadth-First Search (BFS) 1074
				28.10 Case Study: The Nine Tails Problem 1077
	Chapter 29 Weighted Graphs and Applications 1091
				29.1 Introduction 1092
				29.2 Representing Weighted Graphs 1093
				29.3 The WeightedGraph Class 1095
				29.4 Minimum Spanning Trees 1103
				29.5 Finding Shortest Paths 1109
				29.6 Case Study: The Weighted Nine Tails Problem 1118
	Chapter 30 Aggregate Operations for Collection Streams 1129
					30.1 Introduction 1130
					30.2 Stream Pipelines 1130
					30.3 IntStream, LongStream, and DoubleStream 1136
					30.4 Parallel Streams 1139
					30.5 Stream Reduction Using the reduce Method 1141
					30.6 Stream Reduction Using the collect Method 1144
					30.7 Grouping Elements Using the groupingby Collector 1147
					30.8 Case Studies 1150
	Chapter 31 Advanced JavaFX and FXML
	Chapter 42 2-4 Trees and B-Trees
	Chapter 43 Red-Black Trees

************************   Part 5 - Ch 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41, 44   ************************


Part V: Advanced Java Programming (Chapters 32-41, 44)
		This part of the book is devoted to advanced Java programming. Chapter 32 treats the use of multithreading to make programs more responsive and interactive and introduces parallel programming.
		Chapter 33 discusses how to write programs that talk with each other from different hosts over the Internet. Chapter 34 introduces the use of Java to develop database projects.
		Chapter 35 delves into advanced Java database programming. Chapter 36 covers the use of internationalization support to develop projects for international audiences. Chapters 37 and 38 introduce how to use Java servlets and JavaServer Pages to generate dynamic content from Web servers. Chapter 39 introduces modern Web application development using JavaServer Faces. Chapter 40 introduces remote method invocation and Chapter 41 discusses Web services.
		Chapter 44 introduces testing Java programs using JUnit.
	
	Chapter 32 Multithreading and Parallel  Programming
	Chapter 33 Networking
	Chapter 34 Java Database Programming
	Chapter 35 Advanced Database Programming
	Chapter 36 Internationalization
	Chapter 37 Servlets
	Chapter 38 JavaServer Pages
	Chapter 39 JavaServer Faces
	Chapter 40 RMI
	Chapter 41 Web Services
	Chapter 44 Testing Using JUnit

			



